generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum UserRole {
  OWNER
  ADMIN
  OPERATOR
  VIEWER
}

enum Environment {
  DEV
  STAGING
  PROD
}

enum ClusterStatus {
  PROVISIONING
  HEALTHY
  DEGRADED
  MAINTENANCE
}

enum ReplicationMode {
  SYNC
  ASYNC
}

enum NodeRole {
  PRIMARY
  REPLICA
}

enum NodeStatus {
  ONLINE
  OFFLINE
  DRAINING
  MAINTENANCE
}

model Organization {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  users     User[]
  projects  Project[]
}

enum UserStatus {
  ACTIVE
  DISABLED
  LOCKED
  PENDING
}

model User {
  id              String       @id @default(cuid())
  email           String       @unique
  passwordHash    String
  name            String?
  role            UserRole     @default(VIEWER)
  status          UserStatus   @default(ACTIVE)
  orgId           String?
  organization    Organization? @relation(fields: [orgId], references: [id])
  // MFA fields
  mfaEnabled      Boolean      @default(false)
  mfaSecret       String?
  mfaBackupCodes  String[]
  mfaVerifiedAt   DateTime?
  mfaEnforcedAt   DateTime?    // When MFA enforcement started for this user (deadline = this + grace period)
  // Security fields
  failedAttempts  Int          @default(0)
  lockedUntil     DateTime?
  lastLoginAt     DateTime?
  lastLoginIp     String?
  passwordChangedAt DateTime?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  auditLogs       AuditLog[]
  sessions        UserSession[]
  loginHistory    LoginHistory[]
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  ipAddress    String?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  lastActiveAt DateTime @default(now())
}

model LoginHistory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress String?
  userAgent String?
  success   Boolean
  reason    String?
  mfaUsed   Boolean  @default(false)
  createdAt DateTime @default(now())
}

model Project {
  id           String       @id @default(cuid())
  name         String
  environment  Environment  @default(DEV)
  orgId        String
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  clusters     Cluster[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Cluster {
  id              String          @id @default(cuid())
  name            String
  topology        String          @default("standard")
  status          ClusterStatus   @default(PROVISIONING)
  replicationMode ReplicationMode @default(ASYNC)
  projectId       String
  project         Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  nodes           Node[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

enum NodeSyncStatus {
  PENDING
  SYNCING
  SYNCED
  FAILED
  NOT_CONFIGURED
}

model Node {
  id                String         @id @default(cuid())
  name              String
  host              String
  port              Int
  connectionString  String?        @db.Text
  // Database authentication
  dbUser            String?
  dbPassword        String?        @db.Text
  sslEnabled        Boolean        @default(false)
  sslMode           String         @default("disable")
  // Connection status
  role              NodeRole       @default(REPLICA)
  status            NodeStatus     @default(OFFLINE)
  connectionVerified Boolean       @default(false)
  lastConnectionTest DateTime?
  connectionError   String?        @db.Text
  // Routing
  routingWeight     Int            @default(100)
  priority          Int            @default(1)
  // Sync & Replication
  syncEnabled       Boolean        @default(false)
  syncStatus        NodeSyncStatus @default(NOT_CONFIGURED)
  lastSyncAt        DateTime?
  syncError         String?        @db.Text
  replicationEnabled Boolean       @default(true)
  replicationSlot   String?
  replicationLag    Int?           @default(0)
  // Metadata
  pgVersion         String?
  dataDirectory     String?
  clusterId         String
  cluster           Cluster        @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  @@index([clusterId])
  @@index([syncStatus])
}

enum FailoverStatus {
  PENDING
  PRE_CHECK
  IN_PROGRESS
  VALIDATING
  COMPLETED
  FAILED
  ROLLED_BACK
}

enum FailoverType {
  PLANNED
  EMERGENCY
  AUTOMATED
}

model FailoverOperation {
  id              String         @id @default(cuid())
  clusterId       String
  type            FailoverType   @default(PLANNED)
  status          FailoverStatus @default(PENDING)
  sourceNodeId    String
  targetNodeId    String
  reason          String?
  preChecks       String?        @db.Text
  steps           String?        @db.Text
  errorMessage    String?        @db.Text
  startedAt       DateTime?
  completedAt     DateTime?
  rolledBackAt    DateTime?
  initiatedBy     String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([clusterId])
  @@index([status])
}

model RoutingConfig {
  id              String   @id @default(cuid())
  clusterId       String   @unique
  readWriteSplit  Boolean  @default(true)
  primaryWeight   Int      @default(100)
  replicaWeights  String?  @db.Text
  healthThreshold Int      @default(80)
  lagThreshold    Int      @default(100)
  connectionLimit Int      @default(1000)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clusterId])
}

// Connection Endpoints for PostgreSQL proxy routing
enum EndpointMode {
  READ_WRITE
  READ_ONLY
  WRITE_ONLY
  BALANCED
}

enum EndpointStatus {
  ACTIVE
  DISABLED
  MAINTENANCE
}

model ConnectionEndpoint {
  id              String         @id @default(cuid())
  clusterId       String
  name            String
  slug            String         @unique
  mode            EndpointMode   @default(READ_WRITE)
  status          EndpointStatus @default(ACTIVE)
  port            Int            @default(5432)
  sslMode         String         @default("require")
  maxConnections  Int            @default(100)
  poolSize        Int            @default(20)
  idleTimeout     Int            @default(300)
  // Routing weights override
  readWeight      Int            @default(100)
  writeWeight     Int            @default(100)
  // Dynamic credentials
  username        String?
  password        String?
  credentialsCreatedAt DateTime?
  // Stats
  activeConnections Int          @default(0)
  totalConnections  BigInt       @default(0)
  bytesIn           BigInt       @default(0)
  bytesOut          BigInt       @default(0)
  lastUsedAt        DateTime?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([clusterId])
  @@index([slug])
  @@index([status])
}

model NodeLifecycleEvent {
  id          String   @id @default(cuid())
  nodeId      String
  clusterId   String
  eventType   String
  fromStatus  String?
  toStatus    String
  details     String?  @db.Text
  initiatedBy String?
  createdAt   DateTime @default(now())

  @@index([nodeId])
  @@index([clusterId])
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  entityType  String
  entityId    String
  action      String
  beforeState String?  @db.Text
  afterState  String?  @db.Text
  timestamp   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([userId])
  @@index([timestamp])
}

// AI Models

enum AnomalySeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AnomalyType {
  LAG_SPIKE
  LATENCY_ANOMALY
  ERROR_BURST
  LOCK_CONTENTION
  WAL_GROWTH
  DISK_PRESSURE
  CPU_SPIKE
  CONNECTION_SURGE
}

enum RecommendationStatus {
  PENDING
  APPROVED
  APPLIED
  ROLLED_BACK
  REJECTED
}

enum RecommendationType {
  ROUTING_WEIGHT
  LAG_THRESHOLD
  HEALTH_CHECK
  FAILOVER_SCORING
  ADD_REPLICA
  VACUUM_BLOAT
  BACKUP_RETENTION
  CONNECTION_POOLING
}

enum IncidentSeverity {
  SEV1
  SEV2
  SEV3
  SEV4
}

enum IncidentStatus {
  OPEN
  INVESTIGATING
  IDENTIFIED
  MONITORING
  RESOLVED
}

enum ForecastStatus {
  OPEN
  ACKNOWLEDGED
  REMEDIATED
}

model Anomaly {
  id          String          @id @default(cuid())
  clusterId   String
  nodeId      String?
  type        AnomalyType
  severity    AnomalySeverity
  title       String
  description String          @db.Text
  metricValue Float?
  threshold   Float?
  evidence    String?         @db.Text
  resolved    Boolean         @default(false)
  resolvedAt  DateTime?
  createdAt   DateTime        @default(now())

  @@index([clusterId])
  @@index([createdAt])
  @@index([severity])
}

model Forecast {
  id             String         @id @default(cuid())
  clusterId      String
  metricType     String
  currentValue   Float
  predictedValue Float
  predictedAt    DateTime
  confidence     Float
  riskLevel      String
  description    String         @db.Text
  status         ForecastStatus @default(OPEN)
  createdAt      DateTime       @default(now())

  @@index([clusterId])
  @@index([metricType])
  @@index([status])
}

model Recommendation {
  id            String               @id @default(cuid())
  clusterId     String
  type          RecommendationType
  title         String
  description   String               @db.Text
  impact        String               @db.Text
  risk          String
  evidence      String?              @db.Text
  currentValue  String?
  proposedValue String?
  status        RecommendationStatus @default(PENDING)
  appliedAt     DateTime?
  appliedBy     String?
  rolledBackAt  DateTime?
  rolledBackBy  String?
  createdAt     DateTime             @default(now())

  @@index([clusterId])
  @@index([status])
}

model Incident {
  id          String           @id @default(cuid())
  clusterId   String
  severity    IncidentSeverity
  status      IncidentStatus   @default(OPEN)
  title       String
  description String           @db.Text
  rootCause   String?          @db.Text
  timeline    String?          @db.Text
  actionItems String?          @db.Text
  resolvedAt  DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([severity])
}

model ChatMessage {
  id        String   @id @default(cuid())
  sessionId String
  clusterId String?
  role      String
  content   String   @db.Text
  toolCalls String?  @db.Text
  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([clusterId])
}

model Report {
  id          String   @id @default(cuid())
  clusterId   String?
  title       String
  type        String
  prompt      String?  @db.Text
  content     String   @db.Text
  data        String?  @db.Text
  createdBy   String?
  createdAt   DateTime @default(now())

  @@index([clusterId])
  @@index([type])
}

model Metric {
  id        String   @id @default(cuid())
  clusterId String
  nodeId    String?
  name      String
  value     Float
  unit      String?
  timestamp DateTime @default(now())

  @@index([clusterId, name, timestamp])
  @@index([nodeId, name, timestamp])
}

// Phase 3: Backup & Recovery Management

enum BackupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  VALIDATING
  VERIFIED
}

enum BackupType {
  FULL
  INCREMENTAL
  WAL
  PITR
}

model Backup {
  id              String       @id @default(cuid())
  clusterId       String
  nodeId          String?
  type            BackupType   @default(FULL)
  status          BackupStatus @default(PENDING)
  size            BigInt?
  location        String?
  startedAt       DateTime?
  completedAt     DateTime?
  walStart        String?
  walEnd          String?
  pitrTarget      DateTime?
  retentionDays   Int          @default(30)
  verified        Boolean      @default(false)
  verifiedAt      DateTime?
  errorMessage    String?      @db.Text
  metadata        String?      @db.Text
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}

model BackupSchedule {
  id              String   @id @default(cuid())
  clusterId       String   @unique
  enabled         Boolean  @default(true)
  fullBackupCron  String   @default("0 2 * * 0")
  incrBackupCron  String   @default("0 2 * * 1-6")
  walArchiving    Boolean  @default(true)
  retentionDays   Int      @default(30)
  lastFullBackup  DateTime?
  lastIncrBackup  DateTime?
  nextFullBackup  DateTime?
  nextIncrBackup  DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clusterId])
}

// Phase 3: Alert Management

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum AlertStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
  SUPPRESSED
}

model Alert {
  id            String        @id @default(cuid())
  clusterId     String
  nodeId        String?
  ruleId        String?
  severity      AlertSeverity
  status        AlertStatus   @default(ACTIVE)
  title         String
  message       String        @db.Text
  metricName    String?
  metricValue   Float?
  threshold     Float?
  acknowledgedBy String?
  acknowledgedAt DateTime?
  resolvedAt    DateTime?
  resolvedBy    String?
  suppressedUntil DateTime?
  notificationsSent Int       @default(0)
  lastNotifiedAt DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([severity])
  @@index([createdAt])
}

model AlertRule {
  id              String        @id @default(cuid())
  clusterId       String?
  name            String
  description     String?       @db.Text
  enabled         Boolean       @default(true)
  metric          String
  operator        String
  threshold       Float
  duration        Int           @default(60)
  severity        AlertSeverity @default(WARNING)
  cooldownMinutes Int           @default(5)
  notifyEmail     Boolean       @default(true)
  notifyWebhook   Boolean       @default(false)
  webhookUrl      String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([clusterId])
  @@index([enabled])
}

// Phase 3: Connection Pooling Management

enum PoolerType {
  PGBOUNCER
  PGPOOL
  ODYSSEY
}

enum PoolMode {
  SESSION
  TRANSACTION
  STATEMENT
}

model ConnectionPool {
  id                  String     @id @default(cuid())
  clusterId           String     @unique
  enabled             Boolean    @default(true)
  poolerType          PoolerType @default(PGBOUNCER)
  poolMode            PoolMode   @default(TRANSACTION)
  maxClientConn       Int        @default(1000)
  defaultPoolSize     Int        @default(20)
  minPoolSize         Int        @default(5)
  reservePoolSize     Int        @default(5)
  reservePoolTimeout  Int        @default(5)
  maxDbConnections    Int        @default(100)
  serverIdleTimeout   Int        @default(600)
  clientIdleTimeout   Int        @default(0)
  queryTimeout        Int        @default(0)
  serverResetQuery    String     @default("DISCARD ALL")
  serverCheckQuery    String     @default("SELECT 1")
  stats               String?    @db.Text
  lastStatsUpdate     DateTime?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  @@index([clusterId])
}

// Phase 4: Query Performance Analytics

model QueryStats {
  id              String   @id @default(cuid())
  clusterId       String
  nodeId          String?
  queryHash       String
  queryText       String   @db.Text
  calls           Int      @default(0)
  totalTime       Float    @default(0)
  minTime         Float    @default(0)
  maxTime         Float    @default(0)
  meanTime        Float    @default(0)
  rows            BigInt   @default(0)
  sharedBlksHit   BigInt   @default(0)
  sharedBlksRead  BigInt   @default(0)
  tempBlksWritten BigInt   @default(0)
  firstSeen       DateTime @default(now())
  lastSeen        DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([clusterId, queryHash])
  @@index([clusterId])
  @@index([meanTime])
  @@index([calls])
}

model SlowQuery {
  id            String   @id @default(cuid())
  clusterId     String
  nodeId        String?
  queryText     String   @db.Text
  duration      Float
  database      String?
  username      String?
  waitEvent     String?
  state         String?
  explainPlan   String?  @db.Text
  suggestions   String?  @db.Text
  capturedAt    DateTime @default(now())
  analyzed      Boolean  @default(false)
  analyzedAt    DateTime?
  createdAt     DateTime @default(now())

  @@index([clusterId])
  @@index([duration])
  @@index([capturedAt])
}

model IndexRecommendation {
  id            String   @id @default(cuid())
  clusterId     String
  tableName     String
  columnNames   String
  indexType     String   @default("btree")
  reason        String   @db.Text
  estimatedGain Float?
  ddlStatement  String?  @db.Text
  status        String   @default("PENDING")
  appliedAt     DateTime?
  appliedBy     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([clusterId])
  @@index([status])
}

// Phase 4: Replication Health

model ReplicationSlot {
  id              String   @id @default(cuid())
  clusterId       String
  nodeId          String
  slotName        String
  slotType        String
  database        String?
  active          Boolean  @default(false)
  restartLsn      String?
  confirmedFlushLsn String?
  walStatus       String?
  safeWalSize     BigInt?
  retainedWal     BigInt?
  catalogXmin     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([clusterId, slotName])
  @@index([clusterId])
  @@index([nodeId])
}

model ReplicationLag {
  id              String   @id @default(cuid())
  clusterId       String
  nodeId          String
  replayLag       Float?
  writeLag        Float?
  flushLag        Float?
  sentLsn         String?
  writeLsn        String?
  flushLsn        String?
  replayLsn       String?
  walBytes        BigInt?
  syncState       String?
  syncPriority    Int?
  timestamp       DateTime @default(now())

  @@index([clusterId])
  @@index([nodeId])
  @@index([timestamp])
}

model WalActivity {
  id              String   @id @default(cuid())
  clusterId       String
  nodeId          String
  currentLsn      String
  walWrite        BigInt   @default(0)
  walSend         BigInt   @default(0)
  archiveCount    Int      @default(0)
  archiveFailed   Int      @default(0)
  lastArchived    String?
  lastArchivedAt  DateTime?
  lastFailed      String?
  lastFailedAt    DateTime?
  timestamp       DateTime @default(now())

  @@index([clusterId])
  @@index([nodeId])
  @@index([timestamp])
}

// Control Plane Federation Models

enum FederationRole {
  PRINCIPLE
  PARTNER
  STANDALONE
}

enum FederationRequestStatus {
  PENDING
  ACKNOWLEDGED
  REJECTED
  EXPIRED
  PROMOTION_PENDING
}

enum SyncStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

// Represents the local control plane's identity and role
model ControlPlaneIdentity {
  id              String         @id @default(cuid())
  instanceId      String         @unique  // Unique identifier for this instance
  name            String
  domain          String         // The domain/URL of this control plane
  role            FederationRole @default(STANDALONE)
  principleId     String?        // If PARTNER, references the principle's instanceId
  apiKey          String         @unique  // Secret key for federation auth
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
}

// Represents connected control planes (partners or principle)
model FederatedNode {
  id                  String         @id @default(cuid())
  instanceId          String         @unique  // Remote instance's unique ID
  name                String
  domain              String         // The domain/URL of the remote control plane
  role                FederationRole // From our perspective: PRINCIPLE or PARTNER
  apiKey              String?        // Key to authenticate with remote
  status              String         @default("CONNECTED")  // CONNECTED, DISCONNECTED, SYNCING
  lastHeartbeat       DateTime?
  lastSyncAt          DateTime?
  syncEnabled         Boolean        @default(true)
  promotionRequestAt  DateTime?      // When a promotion request was made
  promotionRequestBy  String?        // Who requested promotion
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  requests            FederationRequest[] @relation("NodeRequests")
  syncLogs            SyncLog[]

  @@index([instanceId])
  @@index([role])
  @@index([status])
}

// Partnership requests between control planes
model FederationRequest {
  id              String                   @id @default(cuid())
  nodeId          String?
  node            FederatedNode?           @relation("NodeRequests", fields: [nodeId], references: [id], onDelete: SetNull)
  fromInstanceId  String                   // Instance ID of requester
  fromName        String
  fromDomain      String
  toInstanceId    String?                  // Instance ID of target (null for incoming)
  requestType     String                   // PARTNERSHIP, PROMOTION
  status          FederationRequestStatus  @default(PENDING)
  message         String?                  @db.Text
  apiKey          String?                  // Provided API key for auth
  expiresAt       DateTime?                // For promotion requests (30 sec timeout)
  respondedAt     DateTime?
  respondedBy     String?
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt

  @@index([status])
  @@index([fromInstanceId])
  @@index([requestType])
}

// Sync operation logs
model SyncLog {
  id              String     @id @default(cuid())
  nodeId          String
  node            FederatedNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  direction       String     // PUSH (to partner) or PULL (from principle)
  entityType      String     // Project, Cluster, User, etc.
  entityCount     Int        @default(0)
  status          SyncStatus @default(PENDING)
  errorMessage    String?    @db.Text
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime   @default(now())

  @@index([nodeId])
  @@index([status])
  @@index([createdAt])
}

// MFA Settings for the entire application
model MFASettings {
  id                      String    @id @default(cuid())
  mfaRequiredForAll       Boolean   @default(false)           // Require MFA for all users
  mfaRequiredForDBAdmin   Boolean   @default(true)            // Require MFA to access DB Admin section
  dbAdminMfaDisabledBy    String?                             // Admin who disabled DB Admin MFA
  dbAdminMfaDisabledAt    DateTime?                           // When DB Admin MFA was disabled
  mfaEnforcementStartedAt DateTime?                           // When MFA for all was enabled
  mfaGracePeriodDays      Int       @default(3)               // Grace period for users to enable MFA
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
}

// Track MFA security alerts (admins without MFA, DB Admin MFA disabled, etc.)
model MFASecurityAlert {
  id          String    @id @default(cuid())
  alertType   String                          // DB_ADMIN_MFA_DISABLED, ADMIN_WITHOUT_MFA
  message     String    @db.Text
  adminId     String?                         // The admin who triggered the alert (if applicable)
  adminName   String?                         // Admin name for display
  adminEmail  String?                         // Admin email for display
  resolved    Boolean   @default(false)
  resolvedAt  DateTime?
  resolvedBy  String?
  createdAt   DateTime  @default(now())

  @@index([alertType])
  @@index([resolved])
}

// Superuser Credential Management
enum CredentialStatus {
  ACTIVE
  NEEDS_REENROLLMENT
  SYNCING
}

model SuperuserCredential {
  id                  String           @id @default(cuid())
  username            String           @default("pgbp")
  currentPassword     String           @db.Text  // Stored in plaintext as requested
  passwordHistory     String[]         // Last 6 passwords (stored in plaintext)
  lastRotatedAt       DateTime         @default(now())
  rotationIntervalDays Int             @default(45)
  nextRotationAt      DateTime?
  status              CredentialStatus @default(ACTIVE)
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  propagations        CredentialPropagation[]
}

// Tracks password propagation to individual nodes
model CredentialPropagation {
  id              String              @id @default(cuid())
  credentialId    String
  credential      SuperuserCredential @relation(fields: [credentialId], references: [id], onDelete: Cascade)
  nodeId          String
  clusterId       String
  status          String              @default("PENDING")  // PENDING, SUCCESS, FAILED, NEEDS_REENROLLMENT
  lastAttemptAt   DateTime?
  successAt       DateTime?
  errorMessage    String?             @db.Text
  passwordUsed    String?             // Which password was successful (current or from history)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@unique([credentialId, nodeId])
  @@index([nodeId])
  @@index([status])
}

// Alert for nodes needing re-enrollment
model CredentialAlert {
  id          String   @id @default(cuid())
  nodeId      String
  clusterId   String
  alertType   String   @default("REENROLLMENT_REQUIRED")
  message     String   @db.Text
  resolved    Boolean  @default(false)
  resolvedAt  DateTime?
  resolvedBy  String?
  createdAt   DateTime @default(now())

  @@index([nodeId])
  @@index([resolved])
}
