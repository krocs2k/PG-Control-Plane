generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
    output = "/home/ubuntu/pg_cluster_control_plane/nextjs_space/node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum UserRole {
  OWNER
  ADMIN
  OPERATOR
  VIEWER
}

enum Environment {
  DEV
  STAGING
  PROD
}

enum ClusterStatus {
  PROVISIONING
  HEALTHY
  DEGRADED
  MAINTENANCE
}

enum ReplicationMode {
  SYNC
  ASYNC
}

enum NodeRole {
  PRIMARY
  REPLICA
}

enum NodeStatus {
  ONLINE
  OFFLINE
  DRAINING
  MAINTENANCE
}

model Organization {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  users     User[]
  projects  Project[]
}

model User {
  id           String       @id @default(cuid())
  email        String       @unique
  passwordHash String
  name         String?
  role         UserRole     @default(VIEWER)
  orgId        String?
  organization Organization? @relation(fields: [orgId], references: [id])
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  auditLogs    AuditLog[]
}

model Project {
  id           String       @id @default(cuid())
  name         String
  environment  Environment  @default(DEV)
  orgId        String
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  clusters     Cluster[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Cluster {
  id              String          @id @default(cuid())
  name            String
  topology        String          @default("standard")
  status          ClusterStatus   @default(PROVISIONING)
  replicationMode ReplicationMode @default(ASYNC)
  projectId       String
  project         Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  nodes           Node[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model Node {
  id            String     @id @default(cuid())
  name          String
  host          String
  port          Int
  role          NodeRole   @default(REPLICA)
  status        NodeStatus @default(OFFLINE)
  routingWeight Int        @default(100)
  priority      Int        @default(1)
  clusterId     String
  cluster       Cluster    @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
}

enum FailoverStatus {
  PENDING
  PRE_CHECK
  IN_PROGRESS
  VALIDATING
  COMPLETED
  FAILED
  ROLLED_BACK
}

enum FailoverType {
  PLANNED
  EMERGENCY
  AUTOMATED
}

model FailoverOperation {
  id              String         @id @default(cuid())
  clusterId       String
  type            FailoverType   @default(PLANNED)
  status          FailoverStatus @default(PENDING)
  sourceNodeId    String
  targetNodeId    String
  reason          String?
  preChecks       String?        @db.Text
  steps           String?        @db.Text
  errorMessage    String?        @db.Text
  startedAt       DateTime?
  completedAt     DateTime?
  rolledBackAt    DateTime?
  initiatedBy     String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([clusterId])
  @@index([status])
}

model RoutingConfig {
  id              String   @id @default(cuid())
  clusterId       String   @unique
  readWriteSplit  Boolean  @default(true)
  primaryWeight   Int      @default(100)
  replicaWeights  String?  @db.Text
  healthThreshold Int      @default(80)
  lagThreshold    Int      @default(100)
  connectionLimit Int      @default(1000)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clusterId])
}

model NodeLifecycleEvent {
  id          String   @id @default(cuid())
  nodeId      String
  clusterId   String
  eventType   String
  fromStatus  String?
  toStatus    String
  details     String?  @db.Text
  initiatedBy String?
  createdAt   DateTime @default(now())

  @@index([nodeId])
  @@index([clusterId])
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  entityType  String
  entityId    String
  action      String
  beforeState String?  @db.Text
  afterState  String?  @db.Text
  timestamp   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([userId])
  @@index([timestamp])
}

// AI Models

enum AnomalySeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AnomalyType {
  LAG_SPIKE
  LATENCY_ANOMALY
  ERROR_BURST
  LOCK_CONTENTION
  WAL_GROWTH
  DISK_PRESSURE
  CPU_SPIKE
  CONNECTION_SURGE
}

enum RecommendationStatus {
  PENDING
  APPROVED
  APPLIED
  ROLLED_BACK
  REJECTED
}

enum RecommendationType {
  ROUTING_WEIGHT
  LAG_THRESHOLD
  HEALTH_CHECK
  FAILOVER_SCORING
  ADD_REPLICA
  VACUUM_BLOAT
  BACKUP_RETENTION
  CONNECTION_POOLING
}

enum IncidentSeverity {
  SEV1
  SEV2
  SEV3
  SEV4
}

enum IncidentStatus {
  OPEN
  INVESTIGATING
  IDENTIFIED
  MONITORING
  RESOLVED
}

enum ForecastStatus {
  OPEN
  ACKNOWLEDGED
  REMEDIATED
}

model Anomaly {
  id          String          @id @default(cuid())
  clusterId   String
  nodeId      String?
  type        AnomalyType
  severity    AnomalySeverity
  title       String
  description String          @db.Text
  metricValue Float?
  threshold   Float?
  evidence    String?         @db.Text
  resolved    Boolean         @default(false)
  resolvedAt  DateTime?
  createdAt   DateTime        @default(now())

  @@index([clusterId])
  @@index([createdAt])
  @@index([severity])
}

model Forecast {
  id             String         @id @default(cuid())
  clusterId      String
  metricType     String
  currentValue   Float
  predictedValue Float
  predictedAt    DateTime
  confidence     Float
  riskLevel      String
  description    String         @db.Text
  status         ForecastStatus @default(OPEN)
  createdAt      DateTime       @default(now())

  @@index([clusterId])
  @@index([metricType])
  @@index([status])
}

model Recommendation {
  id            String               @id @default(cuid())
  clusterId     String
  type          RecommendationType
  title         String
  description   String               @db.Text
  impact        String               @db.Text
  risk          String
  evidence      String?              @db.Text
  currentValue  String?
  proposedValue String?
  status        RecommendationStatus @default(PENDING)
  appliedAt     DateTime?
  appliedBy     String?
  rolledBackAt  DateTime?
  rolledBackBy  String?
  createdAt     DateTime             @default(now())

  @@index([clusterId])
  @@index([status])
}

model Incident {
  id          String           @id @default(cuid())
  clusterId   String
  severity    IncidentSeverity
  status      IncidentStatus   @default(OPEN)
  title       String
  description String           @db.Text
  rootCause   String?          @db.Text
  timeline    String?          @db.Text
  actionItems String?          @db.Text
  resolvedAt  DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([severity])
}

model ChatMessage {
  id        String   @id @default(cuid())
  sessionId String
  clusterId String?
  role      String
  content   String   @db.Text
  toolCalls String?  @db.Text
  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([clusterId])
}

model Report {
  id          String   @id @default(cuid())
  clusterId   String?
  title       String
  type        String
  prompt      String?  @db.Text
  content     String   @db.Text
  data        String?  @db.Text
  createdBy   String?
  createdAt   DateTime @default(now())

  @@index([clusterId])
  @@index([type])
}

model Metric {
  id        String   @id @default(cuid())
  clusterId String
  nodeId    String?
  name      String
  value     Float
  unit      String?
  timestamp DateTime @default(now())

  @@index([clusterId, name, timestamp])
  @@index([nodeId, name, timestamp])
}

// Phase 3: Backup & Recovery Management

enum BackupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  VALIDATING
  VERIFIED
}

enum BackupType {
  FULL
  INCREMENTAL
  WAL
  PITR
}

model Backup {
  id              String       @id @default(cuid())
  clusterId       String
  nodeId          String?
  type            BackupType   @default(FULL)
  status          BackupStatus @default(PENDING)
  size            BigInt?
  location        String?
  startedAt       DateTime?
  completedAt     DateTime?
  walStart        String?
  walEnd          String?
  pitrTarget      DateTime?
  retentionDays   Int          @default(30)
  verified        Boolean      @default(false)
  verifiedAt      DateTime?
  errorMessage    String?      @db.Text
  metadata        String?      @db.Text
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}

model BackupSchedule {
  id              String   @id @default(cuid())
  clusterId       String   @unique
  enabled         Boolean  @default(true)
  fullBackupCron  String   @default("0 2 * * 0")
  incrBackupCron  String   @default("0 2 * * 1-6")
  walArchiving    Boolean  @default(true)
  retentionDays   Int      @default(30)
  lastFullBackup  DateTime?
  lastIncrBackup  DateTime?
  nextFullBackup  DateTime?
  nextIncrBackup  DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([clusterId])
}

// Phase 3: Alert Management

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum AlertStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
  SUPPRESSED
}

model Alert {
  id            String        @id @default(cuid())
  clusterId     String
  nodeId        String?
  ruleId        String?
  severity      AlertSeverity
  status        AlertStatus   @default(ACTIVE)
  title         String
  message       String        @db.Text
  metricName    String?
  metricValue   Float?
  threshold     Float?
  acknowledgedBy String?
  acknowledgedAt DateTime?
  resolvedAt    DateTime?
  resolvedBy    String?
  suppressedUntil DateTime?
  notificationsSent Int       @default(0)
  lastNotifiedAt DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([clusterId])
  @@index([status])
  @@index([severity])
  @@index([createdAt])
}

model AlertRule {
  id              String        @id @default(cuid())
  clusterId       String?
  name            String
  description     String?       @db.Text
  enabled         Boolean       @default(true)
  metric          String
  operator        String
  threshold       Float
  duration        Int           @default(60)
  severity        AlertSeverity @default(WARNING)
  cooldownMinutes Int           @default(5)
  notifyEmail     Boolean       @default(true)
  notifyWebhook   Boolean       @default(false)
  webhookUrl      String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([clusterId])
  @@index([enabled])
}

// Phase 3: Connection Pooling Management

enum PoolerType {
  PGBOUNCER
  PGPOOL
  ODYSSEY
}

enum PoolMode {
  SESSION
  TRANSACTION
  STATEMENT
}

model ConnectionPool {
  id                  String     @id @default(cuid())
  clusterId           String     @unique
  enabled             Boolean    @default(true)
  poolerType          PoolerType @default(PGBOUNCER)
  poolMode            PoolMode   @default(TRANSACTION)
  maxClientConn       Int        @default(1000)
  defaultPoolSize     Int        @default(20)
  minPoolSize         Int        @default(5)
  reservePoolSize     Int        @default(5)
  reservePoolTimeout  Int        @default(5)
  maxDbConnections    Int        @default(100)
  serverIdleTimeout   Int        @default(600)
  clientIdleTimeout   Int        @default(0)
  queryTimeout        Int        @default(0)
  serverResetQuery    String     @default("DISCARD ALL")
  serverCheckQuery    String     @default("SELECT 1")
  stats               String?    @db.Text
  lastStatsUpdate     DateTime?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  @@index([clusterId])
}
